import { Arg, Field, FieldResolver, InputType, Int, Mutation, ObjectType, Query, Resolver, Root } from "type-graphql";
import { Message } from "../entity/play/Message";
import { Scene } from "../entity/edit/Scene";
import { Persona } from "../entity/edit/Persona";

@InputType()
class UserMessageInput {
  @Field(() => Int)
  sessionId: number

  @Field(() => Int)
  sceneId: number

  @Field(() => Int)
  userId: number

  @Field()
  text: string
}

/**A response type for when a user's message is sent */
@ObjectType()
class UserMessageResponse {
  /**The user's message that was persisted */
  @Field()
  createdUserMessage: Message

  /**The AI-Persona's response (generated by an LLM) */
  @Field()
  aiPersonaMessage: Message
}

@Resolver(Message)
export class MessageResolver {
  @FieldResolver(() => Scene)
  async scene(@Root() message: Message): Promise<Scene> {
    return Scene.findOne({ where: { id: message.sceneId } })
  }

  @FieldResolver(() => Persona)
  async sender(@Root() message: Message): Promise<Persona> {
    return Persona.findOne({ where: { id: message.senderId } })
  }

  @FieldResolver(() => Persona)
  async recipient(@Root() message: Message): Promise<Persona> {
    return Persona.findOne({ where: { id: message.recipientId } })
  }

  /**Create's a user's message and gets the AI Persona's response */
  @Mutation(() => UserMessageResponse)
  async createUserMessage(@Arg('input') input: UserMessageInput): Promise<UserMessageResponse> {
    // todo
    return null
  }

  /**Get the messages between a player and AI-controlled persona */
  @Query(() => [Message])
  async getConversation(
    @Arg('sessionId', () => Int) sessionId: number, /**The user's session */
    @Arg('personaId', () => Int) personaId: number /**The persona the user has talked to */
  ): Promise<Message[]> {
    // todo
    return []
  }
}