import { Arg, Field, FieldResolver, InputType, Int, Mutation, ObjectType, Query, Resolver, Root } from "type-graphql";
import { Message } from "../entity/play/Message";
import { Scene } from "../entity/edit/Scene";
import { Persona } from "../entity/edit/Persona";
import { assert } from "console";
import { AppDataSource } from "../data-source";
import { Brackets } from "typeorm";
import { getAiReply } from "../ai";
import { StorySession } from "../entity/play/StorySession";
import { Story } from "../entity/edit/Story";

@InputType()
class UserMessageInput {
  @Field(() => Int)
  storySessionId: number

  @Field(() => Int)
  sceneId: number

  /**The persona that the user is playing as */
  @Field(() => Int)
  senderId: number

  @Field(() => Int)
  recipientId: number

  @Field()
  text: string
}

/**A response type for when a user's message is sent */
@ObjectType()
class UserMessageResponse {
  /**The user's message that was persisted */
  @Field()
  userMessage: Message

  /**The AI-Persona's response (generated by an LLM) */
  @Field()
  replyMessage: Message
}

@Resolver(Message)
export class MessageResolver {
  @FieldResolver(() => Scene)
  async scene(@Root() message: Message): Promise<Scene> {
    return Scene.findOne({ where: { id: message.sceneId } })
  }

  @FieldResolver(() => Persona)
  async sender(@Root() message: Message): Promise<Persona> {
    return Persona.findOne({ where: { id: message.senderId } })
  }

  @FieldResolver(() => Persona)
  async recipient(@Root() message: Message): Promise<Persona> {
    return Persona.findOne({ where: { id: message.recipientId } })
  }

  /**Create's a user's message and gets the AI Persona's response */
  @Mutation(() => UserMessageResponse)
  async createUserMessage(@Arg('input') input: UserMessageInput): Promise<UserMessageResponse> {
    assert(input.senderId != input.recipientId, "Sender and recipient must be different")

    console.log("Creating user message")
    const messageRepository = AppDataSource.getRepository(Message)
    const sessionRepository = AppDataSource.getRepository(StorySession)
    const storyRepository = AppDataSource.getRepository(Story)
    const sceneRepository = AppDataSource.getRepository(Scene)
    const personaRepository = AppDataSource.getRepository(Persona)

    const userMessage = messageRepository.create(input)
    userMessage.sender = await personaRepository.findOne({ where: { id: input.senderId } })
    
    const storySession = await AppDataSource
      .getRepository(StorySession)
      .createQueryBuilder("storySession")
      .where('storySession.id = :storySessionId', { storySessionId: input.storySessionId })
      .innerJoinAndSelect("storySession.story", "story")
      .getOne()
    
    const scene = await sceneRepository.findOne({ where: { id: input.sceneId } })
    const recipientPersona = await personaRepository.findOne({ where: { id: input.recipientId } })
    const senderPersona = await personaRepository.findOne({ where: { id: input.senderId } })

    const aiReplyText = await getAiReply({
      story: storySession.story,
      scene: scene,
      to_persona: senderPersona,
      from_persona: recipientPersona,
      message_context: [userMessage] // todo, grab the last 10 or so messages in the conversation
    })
    console.log("AI Reply: " + aiReplyText)

    // Todo: replace this with an actual response from ChatGPT
    const replyMessage = messageRepository.create({
      storySessionId: input.storySessionId,
      sceneId: input.sceneId,
      senderId: input.recipientId,
      recipientId: input.senderId,
      text: aiReplyText
    })

    await messageRepository.insert([userMessage, replyMessage])

    return {
      userMessage: userMessage,
      replyMessage: replyMessage
    }
  }

  /**Get the messages between two personas */
  @Query(() => [Message])
  async getConversation(
    @Arg('storySessionId', () => Int) storySessionId: number, /**The user's session */
    @Arg('firstPersonaId', () => Int) firstPersonaId: number,
    @Arg('secondPersonaId', () => Int) secondPersonaId: number
  ): Promise<Message[]> {
 
    const messages = await AppDataSource
      .getRepository(Message)
      .createQueryBuilder('message')
      .where('message.storySessionId = :storySessionId', { storySessionId: storySessionId })
      .andWhere(
        new Brackets(qb => {
          qb.where(
            new Brackets(qbInner => {
              qbInner.where("message.senderId = :firstPersonaId", { firstPersonaId })
                .andWhere("message.recipientId = :secondPersonaId", { secondPersonaId })
            })
          )
            .orWhere(
              new Brackets(qbInner => {
                qbInner.where("message.senderId = :secondPersonaId", { secondPersonaId })
                  .andWhere("message.recipientId = :firstPersonaId", { firstPersonaId })
              })
            )
        })
      )
      .orderBy('message.createdAt', "DESC")
      .getMany();

    return messages
  }

  /**Given a persona, get the other personas that they have conversations with */
  @Query(() => [Persona])
  async getPersonaConversations(
    @Arg('storySessionId', () => Int) storySessionId: number,
    @Arg('personaId', () => Int) personaId: number
  ): Promise<Persona[]> {

    const distinctPersonas = await AppDataSource
      .getRepository(Persona)
      .createQueryBuilder("persona")
      .where(qb => {
        const subquery = qb.subQuery()
          .select("message.senderId")
          .from(Message, "message")
          .where("message.storySessionId = :storySessionId", { storySessionId })
          .andWhere("message.recipientId = :personaId", { personaId })
          .getQuery();
        const subquery2 = qb.subQuery()
          .select("message.recipientId")
          .from(Message, "message")
          .where("message.storySessionId = :storySessionId", { storySessionId })
          .andWhere("message.senderId = :personaId", { personaId })
          .getQuery();
        return "persona.id IN (" + subquery + " UNION " + subquery2 + ")";
      })
      .andWhere("persona.id != :personaId", { personaId })
      .getMany();

    return distinctPersonas
  }
}