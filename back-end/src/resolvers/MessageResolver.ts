import { Arg, Field, FieldResolver, InputType, Int, Mutation, ObjectType, Query, Resolver, Root } from "type-graphql";
import { Message } from "../entity/play/Message";
import { Scene } from "../entity/edit/Scene";
import { Persona } from "../entity/edit/Persona";
import { assert } from "console";
import { AppDataSource } from "../data-source";
import { Brackets } from "typeorm";
import { getAiReply } from "../ai";
import { StorySession } from "../entity/play/StorySession";
import { Story } from "../entity/edit/Story";
import { Connection } from "../entity/edit/Connection";

@InputType()
class UserMessageInput {
  @Field(() => Int)
  storySessionId: number

  @Field(() => Int)
  sceneId: number

  /**The persona that the user is playing as */
  @Field(() => Int)
  senderId: number

  @Field(() => Int)
  recipientId: number

  @Field()
  text: string
}

/**A response type for when a user's message is sent */
@ObjectType()
class UserMessageResponse {
  /**The user's message that was persisted */
  @Field()
  userMessage: Message

  /**The AI-Persona's response (generated by an LLM) */
  @Field()
  replyMessage: Message
}

@Resolver(Message)
export class MessageResolver {
  @FieldResolver(() => Scene)
  async scene(@Root() message: Message): Promise<Scene> {
    return Scene.findOne({ where: { id: message.sceneId } })
  }

  @FieldResolver(() => Persona)
  async sender(@Root() message: Message): Promise<Persona> {
    return Persona.findOne({ where: { id: message.senderId } })
  }

  @FieldResolver(() => Persona)
  async recipient(@Root() message: Message): Promise<Persona> {
    return Persona.findOne({ where: { id: message.recipientId } })
  }

  /**Create's a user's message and gets the AI Persona's response */
  @Mutation(() => UserMessageResponse)
  async createUserMessage(@Arg('input') input: UserMessageInput): Promise<UserMessageResponse> {
    assert(input.senderId != input.recipientId, "Sender and recipient must be different")

    console.log("Creating user message")
    const messageRepository = AppDataSource.getRepository(Message)
    const sessionRepository = AppDataSource.getRepository(StorySession)
    const storyRepository = AppDataSource.getRepository(Story)
    const connectionRepository = AppDataSource.getRepository(Connection)
    const sceneRepository = AppDataSource.getRepository(Scene)
    const personaRepository = AppDataSource.getRepository(Persona)
    
    const storySession = await AppDataSource
      .getRepository(StorySession)
      .createQueryBuilder("storySession")
      .where('storySession.id = :storySessionId', { storySessionId: input.storySessionId })
      .innerJoinAndSelect("storySession.story", "story")
      .getOne()
    
    const scene = await sceneRepository.findOne({
      where: { id: input.sceneId },
      relations: {
        roles: {
          persona: true,
          actions: true
        }
      }
    })

    const recipientPersona = await personaRepository.findOne({ where: { id: input.recipientId } })
    const senderPersona = await personaRepository.findOne({ where: { id: input.senderId } })
    
    const connection = await connectionRepository.findOne({
      where: {
        sourcePersonaId: input.recipientId,
        targetPersonaId: input.senderId,
      },
      relations: {
        sourcePersona: true,
        targetPersona: true
      }
    })

    const userMessage = messageRepository.create(input)
    userMessage.sender = senderPersona

    const conversation = await this.getConversation(input.storySessionId, input.senderId, input.recipientId, 10)
    conversation.forEach((message) => {
      message.sender = message.senderId == input.senderId ? senderPersona : recipientPersona
    })
    conversation.push(userMessage)

    const aiReplyText = await getAiReply({
      story: storySession.story,
      scene: scene,
      to_persona: senderPersona,
      from_persona: recipientPersona,
      connection: connection,
      message_context: conversation
    })

    const replyMessage = messageRepository.create({
      storySessionId: input.storySessionId,
      sceneId: input.sceneId,
      senderId: input.recipientId,
      recipientId: input.senderId,
      text: aiReplyText
    })

    const insertResult = await messageRepository.insert([userMessage, replyMessage])
    console.log(insertResult)

    return {
      userMessage: userMessage,
      replyMessage: replyMessage
    }
  }

  /**Get the messages between two personas */
  @Query(() => [Message])
  async getConversation(
    @Arg('storySessionId', () => Int) storySessionId: number, /**The user's session */
    @Arg('firstPersonaId', () => Int) firstPersonaId: number,
    @Arg('secondPersonaId', () => Int) secondPersonaId: number,
    @Arg('limit', () => Int, { nullable: true }) limit: number = 10, /**The number of messages to return */
  ): Promise<Message[]> {
 
    const messages = await AppDataSource
      .getRepository(Message)
      .createQueryBuilder('message')
      .where('message.storySessionId = :storySessionId', { storySessionId: storySessionId })
      .andWhere(
        new Brackets(qb => {
          qb.where(
            new Brackets(qbInner => {
              qbInner.where("message.senderId = :firstPersonaId", { firstPersonaId })
                .andWhere("message.recipientId = :secondPersonaId", { secondPersonaId })
            })
          )
            .orWhere(
              new Brackets(qbInner => {
                qbInner.where("message.senderId = :secondPersonaId", { secondPersonaId })
                  .andWhere("message.recipientId = :firstPersonaId", { firstPersonaId })
              })
            )
        })
      )
      .orderBy('message.createdAt', "ASC")
      .limit(limit)
      .getMany();

    return messages
  }

  /**Given a persona, get the other personas that they have conversations with */
  @Query(() => [Persona])
  async getPersonaConversations(
    @Arg('storySessionId', () => Int) storySessionId: number,
    @Arg('personaId', () => Int) personaId: number
  ): Promise<Persona[]> {

    const distinctPersonas = await AppDataSource
      .getRepository(Persona)
      .createQueryBuilder("persona")
      .where(qb => {
        const subquery = qb.subQuery()
          .select("message.senderId")
          .from(Message, "message")
          .where("message.storySessionId = :storySessionId", { storySessionId })
          .andWhere("message.recipientId = :personaId", { personaId })
          .getQuery();
        const subquery2 = qb.subQuery()
          .select("message.recipientId")
          .from(Message, "message")
          .where("message.storySessionId = :storySessionId", { storySessionId })
          .andWhere("message.senderId = :personaId", { personaId })
          .getQuery();
        return "persona.id IN (" + subquery + " UNION " + subquery2 + ")";
      })
      .andWhere("persona.id != :personaId", { personaId })
      .getMany();

    return distinctPersonas
  }
}