import { Arg, Field, FieldResolver, InputType, Int, Mutation, ObjectType, Query, Resolver, Root } from "type-graphql";
import { Message } from "../entity/play/Message";
import { Scene } from "../entity/edit/Scene";
import { Persona } from "../entity/edit/Persona";
import { assert } from "console";
import { AppDataSource } from "../data-source";
import { Brackets } from "typeorm";

@InputType()
class UserMessageInput {
  @Field(() => Int)
  storySessionId: number

  @Field(() => Int)
  sceneId: number

  /**The persona that the user is playing as */
  @Field(() => Int)
  senderId: number

  @Field(() => Int)
  recipientId: number

  @Field()
  text: string
}

/**A response type for when a user's message is sent */
@ObjectType()
class UserMessageResponse {
  /**The user's message that was persisted */
  @Field()
  userMessage: Message

  /**The AI-Persona's response (generated by an LLM) */
  @Field()
  replyMessage: Message
}

@Resolver(Message)
export class MessageResolver {
  @FieldResolver(() => Scene)
  async scene(@Root() message: Message): Promise<Scene> {
    return Scene.findOne({ where: { id: message.sceneId } })
  }

  @FieldResolver(() => Persona)
  async sender(@Root() message: Message): Promise<Persona> {
    return Persona.findOne({ where: { id: message.senderId } })
  }

  @FieldResolver(() => Persona)
  async recipient(@Root() message: Message): Promise<Persona> {
    return Persona.findOne({ where: { id: message.recipientId } })
  }

  /**Create's a user's message and gets the AI Persona's response */
  @Mutation(() => UserMessageResponse)
  async createUserMessage(@Arg('input') input: UserMessageInput): Promise<UserMessageResponse> {
    assert(input.senderId != input.recipientId, "Sender and recipient must be different")

    const messageRepository = AppDataSource.getRepository(Message)

    const userMessage = messageRepository.create(input)
    
    // Todo: replace this with an actual response from ChatGPT
    const replyMessage = messageRepository.create({
      storySessionId: input.storySessionId,
      sceneId: input.sceneId,
      senderId: input.recipientId,
      recipientId: input.senderId,
      text: "Hello World (this text will be generated by AI in the future)"
    })

    await messageRepository.insert([userMessage, replyMessage])

    return {
      userMessage: userMessage,
      replyMessage: replyMessage
    }
  }

  /**Get the messages between two personas */
  @Query(() => [Message])
  async getConversation(
    @Arg('storySessionId', () => Int) storySessionId: number, /**The user's session */
    @Arg('firstPersonaId', () => Int) firstPersonaId: number,
    @Arg('secondPersonaId', () => Int) secondPersonaId: number
  ): Promise<Message[]> {
 
    const messages = await AppDataSource
      .getRepository(Message)
      .createQueryBuilder('message')
      .where('message.storySessionId = :storySessionId', { storySessionId: storySessionId })
      .andWhere(
        new Brackets(qb => {
          qb.where(
            new Brackets(qbInner => {
              qbInner.where("message.senderId = :firstPersonaId", { firstPersonaId })
                .andWhere("message.recipientId = :secondPersonaId", { secondPersonaId })
            })
          )
            .orWhere(
              new Brackets(qbInner => {
                qbInner.where("message.senderId = :secondPersonaId", { secondPersonaId })
                  .andWhere("message.recipientId = :firstPersonaId", { firstPersonaId })
              })
            )
        })
      )
      .orderBy('message.createdAt', "DESC")
      .getMany();

    return messages
  }
}